# Концепция
Аутентификация осуществляется на основе HMAC алгоритма. Что это значит в двух словах.
На Клиенте и на Сервере есть одинаковый секретный ключ, которые они не передают по сети.
С этого ключа Клиент подписывает свой запрос, а Сервер проверяет эту подпись.
Клиент передаёт на Сервер только свой access_id. 
На Сервере хранится таблица соответствий access_id => secret_key.

## Модульность
Каждое специфичное API будет частью гема, реализующего эту функциональность.
Каждый гем содержит документацию к API в редейме или доп. документе.

## Версионирование
Предлагается применить сквозное версионирование API.
При работе с API в урле обязательно указывается версия.
Маршруты и права конкретного API будут располагаться в конкретном геме.
В каждом геме, на ряду с конкретными маршрутами описывающими конкретные версии, должен быть универсальный маршрут для любой версии и для версии `edge`, указывающий на крайнюю версию API. Это необходимо для легкого выпуска новой версии API, что бы не нужно было менять все гемы. Если указанная версия не реализована в конкретном API, то будет использована крайняя версия.

Устаревшие версии будут закрываться, а клиенту при запросе будет возвращаться специальный код. Это реализуется в маршрутах, с помощью обработки всех экшинов устаревшей версии, с помощью спец контроллера.

пример урла:
`http://www.pulscen.ru/api/v1/products`
`http://ekb.pulscen.ru/api/v1/products`
`http://krepika.pulscen.ru/api/v1/products`
`http://www.krepika.ru/api/v1/products`
`http://www.krepika.ru/api/v22/products` -> `http://www.krepika.ru/api/v1/products` (т.к. посл. доступная v1)

## Возможности
- Авторизация с помощью access_id (HMAC)
- Авторизация с помощью session_id (будучи авторизованным на портале)
- Через логин, пароль и device_id получить secure_key, access_id и auth_key
- Через auth_key получить secure_key и access_id

Авторизация через session_id не рекомендуется к использованию и сделана для плавного перехода мобильного приложения на новое API и для обеспечения работы через API JavaScript приложений (например ЕТИ)

## Формат ответа
- Ответ формируется в формате JSON
- Проверять формат запроса:
  - если запрос XHR, то отдавать всегда 200
  - если запрос не XHR, то отдавать соотв. результату код

## Разработка и отладка
Предполагается возможность легкой разработки и отладки через браузер и curl. Для этого нужно сделать:
- все токены и основные параметры читать как из заголовков, так и через параметры
- в тестовом окружении, при наличии специального параметра `check_signature=0`, не проверять подпись запроса

## Плюсы подхода
- универсальность. будут одинаково взаимодействовать наши внутренние сервисы и внешние клиенты
- легкость реализации на клиенте
- не нужно передавать логи/пароль (безопасность)
- не нужно хранить сессию, между запросами
- независимая авторизация на разных устройствах

# Реализация
## Gem `apress-api`
### DB
*api_clients*

id - integer
name - string
device_id - string
access_id - string
secure_key - string
secure_key_expire_at - datetime
auth_key - string
auth_key_expire_at - datetime
created_at - datetime
updated_at - datetime

### Rails

#### Apress::Api::BaseController < ActionController::Base или ActionController::Metal
- `#authenticate`
  - берем из заголовков `Authorization` (желательно брать из параметров, для легкой работы через браузер и curl)
  - в качестве значения заголовка приходит "access_id:signature".
  - Ищем secure_key в таблице api_clients и проверяем signature.
  - Всю эту работу выполняет гем [api-auth](https://github.com/mgomes/api_auth)
- остальная различная специфика типа server_error, not_found, forbidden

### Dependencies 
api-auth, jbuilder


## Gem `apress-api-application`
Всё логика прекрасно подходит до того момента, пока мы контролируем доступ к Клиенту.
Как только этот контроль теряется, то проблема хранения secure_key всплывает на первое место.
Такими клиентами являются мобильные приложения. 
Юзер не может вводить в качестве логина строку из 128 символов =).

Предлагается следующая, не идеальная схема. (идеальная схему можно прочитать [вот здесь](http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/), 
искать по слову Twitter).
Юзер в мобилке вводит логин/пароль, которые отправляются на Сервер (желательно по SSL, чтобы не светить secure_key). Вместе с этими данными передается device_id - идентификатор устройства.
Сервер находит User, находит соотв. запись в таблице api_clients, по user_id и device_id, если записи нет, то создает. В ответ возвращает access_id, secure_key, auth_key и доп. информацию, если нужно.

*secure_key* - это секретный ключ, известный только клиенту и серверу, с помощью него подписывается запрос. Время жизни ограничено минутами.

*device_id* - является не обязательным, если он не указан используется дефолт - 0.
Этот идентификатор нужен, для разделения авторизационных реквизитов между несколькими устройствами одного пользователя.

*auth_key* - это авторизационный ключ. Существует для того, что бы клиенты не хранили логин и пароль пользователя, а вместо этого авторизовывались через auth_key. Время жизни ограничено днями?!

Ключ регенерируется при каждой авторизации через hello, как по связке login/password/device_id, так и через auth_key.

Также этот гем авторизует пользователя. Т.е. есть аутентификация, а есть авторизация.
Авторизация - это определение роли пользователя и его доступных прав.
Авторизация будет работать стандартная портальная.

Помимо 

### DB
Добавляет в таблицу `api_clients` столбец `user_id: :integer`

### Rails

### Apress::Api::Application::Extensions::Apress::Api::BaseController
- `#hello`
  - В идеале должен находится на отдельном SSL домене, типо `auth.pulscen.ru`
  - Сюда приходят логин/пароль/device_id ИЛИ auth_key
  - Ведётся поиск по таблице api_users, по user_id/device_id ИЛИ по auth_key
  - Если записи нет, то создаётся новая
  - ВСЕГДА генерируется/регенерируется secure_key, auth_key
  - При авторизации через auth_key сервер проверяет не протух ли он, если протух, не авторизует, возвращает спец код ответа
  - Возвращает клиенту access_id
  - Возвращает клиенту secure_key
  - Возвращает клиенту auth_key
  - Возвращается клиенту служебную информацию
- `#authenticate`
  - если пришёл заголовок с сессией, то авторизуем обычным способом через authlogic
  - иначе
  - super (авторизация по HMAC)
  - находит пользователя по user_id в таблице api_clients
  - выполняет авторизацию юзера

Т.е. при работе с каждым экшеном API будет возможность авторизации через access_id и session_id.

Экшн *hello* должен так же версионироваться.

### Dependencies 
apress-api, apress-clearance, apress-application

# Общая схема работы
- ЕСЛИ **есть access_id**, ТО: (1)
  - запрашиваю любые урлы API, в заголовках передаю access_id, sign
  - слежу за протуханием secure_key, при протухании, работаю по п. 2 или п. 3
- ИНАЧЕ ЕСЛИ **нет access_id и есть auth_key**, ТО: (2)
  - авторизуюсь через hello, в заголовке передаю auth_key:
    - ЕСЛИ токен не протух, ТО: получаю access_id, secure_key и auth_key (сервер всегда обновляет их), работаю по п. 1
    - ЕСЛИ токен протух (получен спец ответ), ТО: работаю по п. 3
- ИНАЧЕ ЕСЛИ **нет access_id, нет auth_key или он протух**, ТО: (3)
  - авторизуюсь через hello, в заголовке передаю login/password/device_id
  - получаю access_id, secure_key и auth_key
  - работаю по п.1
- ИНАЧЕ ЕСЛИ **нет access_id, нет auth_key, нет логина и пароля, НО есть авторизация на портале и кука с сессией** (Javascript), ТО: (4)
  - запрашиваю любые урлы API, в куке передаю ид сессии.

# Дополнительно
- отказаться от драппера в пользу джейбилдера
- отпределять мобайл роль по юзер агенту
- маршруты должны жить на текущем домене (на всех компанейских + портальных)
- в хелло можно добавить служ. инфу, время жизни токена, доступные версии и т.д
- при логауте, нужно экспаирить secure_key и auth_key

# Перевод на новое API мобильного приложения
Какое-то время мобильному приложению придется работать с двуми API параллельно. Новый функционал будем реализовывать в новом API, старый будет доживать в старом. Постепенно, старое API удалим.
