# Правила тестирования

## Содержание

+ [Что нужно тестить](https://github.com/abak-press/apress-application/blob/reg_by_email/docs/tests/javascript/main_principles.md#Что-нужно-тестить)
+ [Основные принципы написания тестов](https://github.com/abak-press/apress-application/blob/reg_by_email/docs/tests/javascript/main_principles.md#Основные-принципы-написания-тестов)


## Что нужно тестить.

   - **Тестируем только публичное API**

     В нашей модульной системе публичным API являются события, обрабатываемые в модуле, и соответствующие данным событиям обработчики.

     **Пример**

     На ссылке весит обработчик события "click", согласно которому при клике по ссылке текст данной ссылки меняется на текст из data-атрибута этой ссылки.

     Ваша задача протестировать конечный требуемый результат события 'click'.

     То есть ваша задача:
     1. Создать fixture ссылки.
     2. Написать тест, который эмулирует клик по ссылке и проверяет текст внутри ссылки на соответствие ожидаемому.

     В более сложных примерах вам нужно будет сэмулировать клик + аякс-запрос + api БД, чтобы, например, проверить, что
     при клике по ссылке и в случае успешного запроса на сервер в сообтветствующем блоке отображается flash сообщение, соответствующее ожидаемому.

     Много различных примеров вы можете найти по [данной ссылке](https://github.com/abak-press/apress-clearance/tree/reg-by-email/spec/javascripts). Это тесты, написанные для авторизационного компонента.

     **Итак, мы тестируем только публичное API.**

  - **Когда очень нужно протестировать приватный функцинал**

     Но существуют кейсы, когда модуль содержит достаточно серьёзный приватный функционал, который вы хотели бы протестить.

     Например, вы реализовали модуль формы, который в том числе валидирует данные на клиенте. И вы хотите проверить корректность работы самой валидации.
     Доступа к методам валидации нет. Это модуль формы. Его ответственность слушать определённый набор событий и корректно их обрабатывать. Всё остальное (в том числе и валидация)
     спрятано под капотом.

     **Во-первых**, этот кейс тестить нужно. И можно пойти простым путём и тестировать наличие и контент сообщений об ошибках, который косвенно вам будет
     говорить о корректности работы валидации. Но это весьма хрупкие тесты. Почему? Потому что теперь ваши тесты валидации зависят от того, в каком
     именно элементе вы выводите сообщения, а также от контента этих сообщений. Чем больше таких зависимостей - тем более хрупкими являются тесты, поскольку
     изменив текст сообщения или блок, в котором вы размещаете эти сообщения - вам нужно будет корректировать тесты.

     **Во-вторых**, этот кейс нужно тестить правильно. Для этого следует выделить API валидации в отдельный сервис/модуль. В данном случае это
     API будет публичным, и вы сможете легко получить к нему доступ и протестировать все необходимые кейсы. Бонусом вы получаете сервис, который сможете
     впоследствии имплементировать в других компонентах приложения, который уже будет протестирован.

   - **Тестировать нужно и конечный результат, и сайд эффекты**

     Примером конечного резельтата может служить смена класса элемента, смена содержимого и пр.
     Примером сайд-эффектов может служить обновление конфигов app.config (в процессе выполнения модуль изменил значение одного или нескольких конфигов).

     Конечный результат и сайд эффекты - это необходимый минимум того, что нужно протестить. И зачастую этого вполне достаточно.

   - **Это же интеграционные тесты**

     Вы скажете, что во многих случаях наши тесты будут не юнит тестами, а интеграционными. И будете правы. Тут грань между юнит и интеграционными тестами стирается.
     Их можно рассматривать и в качестве юнит тестов (модуль - один большой юнит), и в качестве интеграционных тестов. Но для простоты и порядка такие тесты мы будем
     продолжать называть именно юнит тестами, поскольку в них всё же больше от юнит тестирования.

     Именно такой принцип тестирования, на мой взгляд, является наиболее оптимальным.
     Я считаю данный подход наиболее оптимальным, поскольку при таком подходе нас интересует начальное событие и конечный результат. Мы не заостряем внимание на деталях реализации.
     Ведь реализация может быть разной при одном и том же результате. Таким образом такой подход позволяет избежать необходимости переписывать тесты в частности по результатам рефакторинга,
     поскольку изменяются только детали реализации. Результат же должен остаться тот же.
     В результате наши тесты становятся менее хрупкими (не зависящими от деталей реализации) и более надёжными. В результате вы меньше времени тратите на написание и правку тестов и получаете тот же результат,
     что и при детальном покрытии тестами всего кода.


## Основные принципы написания тестов.

   - Для каждого модуля - свой отдельный файл с тестами.

   - Во внешнем describe-блоке указывайте название модуля, который тестируете.

   - Разделяйте тесты на логические describe-блоки, чтобы каждый блок описывал конкретную фичу, конкретный метод, конкретную часть модуля.

   - При подготовке к написанию тестов - вы должны подготовить среду тестирования, определить её начальное состояние.

     Делать это следует в beforeEach - блоке.
     Это необходимо для того, чтобы не было утечки данных в тестах, чтобы каждый следующий кейс не зависел от результатов выполнения предыдущего кейса и не появлялись ложные тесты.

   - Определяйте глобальные переменные, которые планируете использовать в большом количестве спеков во внешнем describe-блоке перед beforeEach.

     При этом, если значения этих переменных изменять не планируется, то сразу здесь же и значения присваивайте. Если спеки меняют значения данных переменных,
     то вам необходимо выполнять присвоение значений данныx переменных в beforeEach-блоке.

   - Не дублируйте функционал от спеки к спеке. Создавайте тестовые утилиты.

   - Не экономьте на переменных. Принцип написания тестов несколько отличается от написания основного кода.

     Мы привыкли создавать переменные только в том случае, если значения, сохранённые в них, реиспользуются, например, в методе. И лишь иногда эти
     переменные мы создаём также и для описания сохраняемых в них данных. Но делаем это с большой осторожностью, поскольку вопрос оптимизации и производительности никто не отменял.
     Относительно тестов другая ситуация. Они не выполняются на проде и нам не столько важна скорость выполнения тестов, сколько их читабельность.
     Ведь тесты служат не только для проверки корректности написания кода, но и для его документирования.
     Поэтому в случае написания тестов хорошей практикой является создание переменных именно для описания хранимых в них данных. И зачастую не важно, что они не реиспользуются.

   - Старайтесь, чтобы каждый it содержал один expect. В рамках отдного кейса старайтесь делать одну конкретную проверку. Не всегда, конечно, это удастся сделать.

     Иногда нужно проверить данные до и после. Иногда нужно проверить целый набор данных на соответствие ожидаемым значениям. В данных ситуациях вам придёся делать несколько assertions.
     Но ищите возможность тестировать только один конкретный кейс, делать один конкретный expect.

   - Проверяйте тесты, делая ложные предположения.

     Например, вы ожидаете, что результат будет true. Проверьте и убедидесь, что тест зелёный.
     А теперь проверьте даст ли false красный тест. Бывает ситуации, когда false тоже даёт зелёный тест, хотя должен давать красный.
     Это чёткий индикатор того, что либо тесты написаны некорректно, либо нужно править основной код.

   - Мокать данные и процессы можно и нужно.

   - Пользуйтесь fixture для работой с DOM.

   - Написали новый код - тестируйте его. Отрефакторили существующий код - протестируйте то, что затронули рефакторингом. Пофиксили баг - протестируйте кейс, который пофиксили.
