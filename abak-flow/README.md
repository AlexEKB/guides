# Работа с исходным кодом и репозиторием проекта

## Стратегия ветвления 

Используется стратегия, основанная на совмещение двух подходов
- https://github.com/nvie/gitflow
- http://scottchacon.com/2011/08/31/github-flow.html

Подход git-flow использует следующий набор веток:
- master - всегда пригодна для развертывания
- develop - основная ветка разработки
- hotfix - ветка для изменений, которые попадут на продакшен сервер
- feature - ветки для крупных задач

Github-flow же наоборот ведет основную разработку в ветке master, но при этом master является пригодным для развертывания в любой момент.

В итоге, применят следующий набор правил, для разработки на github:
- Вся разработка любой задачи и функционала ведется только в ветках **feature**
- Разработанный функционал из ветки **feature** оформляется pull request только в ветку **develop**
- Все исправления ошибок, которые должны попасть на продакшен сервер делаются только в ветках **hotfix**, основанной на ветке **master**
- Исправленные ошибки из ветки **hotfix** оформляются pull request только в ветку **master**
- После получения исправлений на текущий момент в репозитории инициируется merge ветки **master** в **develop**

Для разработчика задачи делятся на 2 типа: новый функционал (фича) и хотфикс.

Для автоматизации процесса создан гем: https://github.com/Strech/abak-flow


## Именование веток

Ветка с новой функциональностью именуется *feature/task-001*.
Ветка с хотфиксом именуется *hotfix/task-001*.

*task-001* – это полный номер задачи из JIRA.
Вместо номера задачи может использоваться человеко-читаемое название ветки, например *feature/moneta*.


## Выпуск релиза

Обычно релиз выпускается с ветки master, но в некоторых случаях, после разработки больших фич или рефакторинга, когда стабильность не гарантируется, допускается выпускаться с develop или feature веток. После выпуска, мониторится, состояние проекта и принимается решение о том, что функциональность стабильна и может быть смерджена в master.


## Теггирование релизов

Перед выпуском релиза, на ветке master, создается тег в формате: *YYYYMMDD* для релиза и *YYYYMMDD-fix* для хотфикса.

Желательно, в теге указывать дополнительную информацию, такую как: 
ссылка на версию в JIRA
особенности релиза


## Версионирование функций БД

При изменении любой хранимой процедуры или других хранимых объектов БД, обязательно нужно ее положить под git.
Путь до хранимки должен выглядеть так: `db/{schema}/{function_name}.sql`
Миграцию нужно наследовать от `Core::Migration`
Если хранимка отсутствует в git, то перед редактированием необходимо, отдельным коммитом ее туда добавить.



# Требования к оформлению коммитов

Для оформления сообщения коммита следует использовать следующий шаблон:
```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
TASK-001
```

## Заголовок
### Тип коммита
Возможные типы:
- feature - используется при добавлении новой функциональности уровня приложения
- fix - если исправили какую-то серьезную багу
- docs - всё, что касается документации
- style - исправляем опечатки, исправляем форматирование
- refactor - рефакторинг кода приложения
- test - всё, что связано с тестированием
- chore - обычное обслуживание кода

Можно указывать несколько типов через запятую.

### Область действия
Здесь следует написать затронутые части (например, lynx или tool_chain)

### Сообщение

**Лучше написать грамотно по-русски, чем неграмотно по-английски!**

Общий стиль:
действие (с маленькой буквы) + для какой сущности + (необязательно подробности)

**На английском:**

`fix NoMethodError in RemoteReader`

Первое слово - глагол в неопределнной форме.

**На русском:**

`исправление ошибки NoMethodError в RemoteReader'е`

Первое слово - отглагольное существительное.

Не нужно писать в сообщении номер таска из Джиры или тикета с Гитхаба - для этого есть тело коммита (см. далее).

Например:

`fix(lynx): fix NoMethodError in RemoteReader`

`docs(all): provide README.md with "Commit messages" section`

`style(csv): исправление форматирования в bin/csv2json`

### Тело
Заполнение тела коммита опционально. Нужно в том случае, если описание решенной проблемы достаточно сложно и не может уместиться в строку заголовка.Тело сообщения отделяется от заголовка одной пустой строкой и заполняется произвольно.


Последней строкой обязательно указывается номер закрываемого (закрываемых) тасков из JIRA или тикетов с Github, если она есть конечно.
